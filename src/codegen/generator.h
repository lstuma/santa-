#ifndef generator_h
#define generator_h

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <array>
#include <list>
#include <iomanip>
#include <elfio/elfio.hpp>

#include "../astnode.h"
#include "../color.h"

class FunctionEntry {
	/*
		Represents an entry in the FunctionTable class.
	*/
	public:
		std::string identifier;
		int argc;
		uint32_t _address;
		ASTNode node;

		std::string to_string() {
			std::string s = "{";
			s += Color::bhblue + this->identifier + Color::reset + ", ";
			s += Color::bhblue + std::to_string(this->argc) + Color::reset + ": " + Color::bhblue;
			unsigned char* addr = this->address();
			std::stringstream addr_stream;
			addr_stream <<
				 "0x" << std::hex << (int)addr[0] << " " <<
				 "0x" << std::hex << (int)addr[1] << " " <<
				 "0x" << std::hex << (int)addr[2] << " " <<
				 "0x" << std::hex << (int)addr[3] << ": " <<
				 "0x" << std::hex << this->_address;
			s += addr_stream.str();
			s += Color::reset + "}";
			return s;
		};

		unsigned char* address() {
			unsigned char* address = (unsigned char*) &(this->_address);
			return address;
		};

		FunctionEntry(std::string identifier, int argc, uint32_t _address, ASTNode node) {
			this->identifier = identifier;
			this->argc = argc;
			this->_address = _address;
			this->node = node;
		};

		FunctionEntry(std::string identifier, int argc) {
			this->identifier = identifier;
			this->argc = argc;
			this->_address = (uint32_t) 0x0;
			this->node = ASTNode();
		};
};

class FunctionTable {
	/*
		This class contains a table of functions in the code, thus their signature and address.
	*/
	public:
		std::list<FunctionEntry> table;

		std::string to_string() {
			std::string s = "│ " + Color::bhyellow + "FunctionTable" + Color::reset + "\n├──────────────────────────────────────────\n";
			for(FunctionEntry entry: this->table) {
				s += "│ " + Color::bhyellow + "> " + Color::reset + entry.to_string() + "\n";
			}
			return s;
		}

		void add(std::string identifier, int argc, uint32_t address, ASTNode node) {
			/*
				Adds a new FunctionEntry object to the table.
				Call this function when new function has been generated by code generator.
			*/
			this->table.push_back(FunctionEntry(identifier, argc, address, node));
		};

		FunctionEntry* find(std::string identifier, int argc) {
			/*
				Finds FunctionEntry with the specified signature.

				rtype: found entry
			*/
			for(std::list<FunctionEntry>::iterator entry = this->table.begin(); entry != this->table.end(); ++entry)
				if((*entry).identifier == identifier)
					return &(*entry);
			return nullptr;
		};

};

class DataEntry {
	/*
		Represents an entry in the DataTable class.
	*/
	public:
		std::string identifier;
		uint32_t _address;
		// vlaue used for static computation of expressions at compile time
		int value;

		std::string to_string() {
			std::string s = "{";
			s += Color::bhblue + this->identifier + Color::reset + ": " + Color::bhblue + std::to_string(this->value) + Color::reset + ": " + Color::bhblue;
			unsigned char* addr = this->address();
			std::stringstream addr_stream;
			addr_stream <<
				 "0x" << std::hex << (int)addr[0] << " " <<
				 "0x" << std::hex << (int)addr[1] << " " <<
				 "0x" << std::hex << (int)addr[2] << " " <<
				 "0x" << std::hex << (int)addr[3] << ": " <<
				 "0x" << std::hex << this->_address;
			s += addr_stream.str();
			s += Color::reset + "}";
			return s;
		};

		unsigned char* address() {
			unsigned char* address = (unsigned char*) &(this->_address);
			return address;
		};

		DataEntry(std::string identifier, uint32_t _address, int value) {
			this->identifier = identifier;
			this->_address = _address;
			this->value = value;
		};

		DataEntry(std::string identifier) {
			this->identifier = identifier;
			this->_address = (uint32_t) 0x0;
			this->value = 0;
		};
};

class DataTable {
	/*
		This class contains a table of references to data in the .data segment, thus identifiers and their address.
	*/
	public:
		std::list<DataEntry> table;

		std::string to_string() {
			std::string s = "│ " + Color::bhyellow + "DataTable" + Color::reset + "\n├──────────────────────────────────────────\n";
			for(DataEntry entry: this->table) {
				s += "│ " + Color::bhyellow + "> " + Color::reset + entry.to_string() + "\n";
			}
			return s;
		}

		void add(std::string identifier, uint32_t address, int value) {
			/*
				Adds a new FunctionEntry object to the table.
				Call this function when new function has been generated by code generator.
			*/
			this->table.push_back(DataEntry(identifier, address, value));
		};

		DataEntry* find(std::string identifier) {
			/*
				Finds FunctionEntry with the specified signature.
			
				rtype: DataEntry found
			*/
			for(std::list<DataEntry>::iterator entry = this->table.begin(); entry != this->table.end(); ++entry)
				if((*entry).identifier == identifier)
					return &(*entry);
			return nullptr;
		};

};


class Generator {
	/*
		This class facilitates code generation.
		It transforms a valid AST into executable code and writes the code to a file in the ELF file format.
	*/
	public:
		// the abstract syntax tree to generate code from
		ASTNode ast;
		// class used for converting to elf format
		ELFIO::elfio writer;

		// table of variables in .data
		DataTable data_table;
		// table of functions in .text
		FunctionTable function_table;

		Generator(ASTNode ast);
		// generates elf file and writes it to specified paths
		bool generate();

	private:
		// generates .text and .data segments
		bool generate_segments(ELFIO::section* text_sec, ELFIO::section* data_sec, ELFIO::segment* text_seg, ELFIO::segment* data_seg);
		// updates addresses in .text segment to align correctly with .data section
		bool update_addresses();

		// generate data semgnet
		void generate_data(ELFIO::section* data);
		// evaluates the value of a static expression
		int eval_static_expression(ASTNode expr);

		// generate text segment
		void generate_text(ELFIO::section* text);
		// search for function definitions in node children
		void generate_func_table(ASTNode node);
		// generate function code
		std::string generate_text_func_def(ASTNode node, int* length);
		// generate function call code
		std::string generate_text_func_call(ASTNode node, int* length);
		// generate expression code
		std::string generate_text_expr(ASTNode node, int* length);
		// generate conditional code
		std::string generate_text_cond(ASTNode node, int* length);
		// generate variable definition code
		std::string generate_text_var_def(ASTNode node, int* length);
};

#endif